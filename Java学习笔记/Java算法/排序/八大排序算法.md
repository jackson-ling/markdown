# 十大排序算法

## 目录

## 注意：以下排序均==属于内部排序==

- ## （1）插入排序
  - ## 直接插入排序
  - ## 折半插入排序
  - ## 希尔排序
- ## （2）交换排序
  - ## 冒泡排序
  - ## 快速排序
- ## （3）选择排序
  - ## 简单选择排序
  - ## 堆排序（树形选择排序）
- ## （4）归并排序
- ## （5）基数排序

---

# 一、插入排序

![alt text](插入排序动图.gif)

# 1. 直接插入排序

## （1）整体思路

## 通过动图可以形象的理解到

- ## 1. 抽出一张牌，和当前元素之前的元素逐个比较，如果比当前元素小，该元素就后移，直到找到插入位置
- ## 2. 在==无序序列==中==抽取一张牌==，通过比较插入到有序序列中

## 说明：（惯用思想）==初始时视第一个元素是有序的==，之后通过排序逐渐增大有序序列的长度

## （2）代码实现

## 第一种写法：==while 循环==（==更规范==）

```java
public static void insert_sort(int[] arr) {
    /*
    插入排序的思想：从无序的序列中拿一个数，通过比较的方式插入到有序序列中
    初始状态：假设第一个数是有序的，从第二个元素开始，和有序序列比较，然后插入
        */

    // 在无序序列中抽取一张牌
    for (int i = 1; i < arr.length; i++) {

        // 记录要插入的元素值，位置位于有序序列的末尾
        int insertvalue = arr[i];

        // 在有序序列中从后往前和插入元素比较，找到插入位置
        int j = i - 1;

        /*

        1 2 3 9 10 15 5

        插入5：需要插入在3的后面。所以只要插入元素比当前比较元素小，就往后移

            */
        // 推荐这种写法，更规范
        while (j >= 0 && insertvalue < arr[j]) {
            arr[j + 1] = arr[j]; //  元素后裔
            j--;
        }

        // 插入元素（插入到  比当前插入元素小的 元素  的后面）
        arr[j + 1] = insertvalue;
    }
}
```

## 第二种写法：使用==for 循环==

```java
public static void insert_sort_1(int[] arr) {
    // 第二种写法：使用for循环
    for (int i = 1; i < arr.length; i++) {
        int insertvalue = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) {
            if (insertvalue < arr[j]) {
                arr[j + 1] = arr[j];
            }
            else{
                break; // 如果 insertvalue >= arr[j] 就退出循环
            }
        }
        arr[j + 1] = insertvalue;
    }
}
```

---

# 2. 折半插入排序
