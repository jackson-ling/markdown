# 冒泡排序

## 思想：经过一轮遍历比较，把最大的放在数组的末尾

```java
int[] a = {3, 2, 1};
for( int i = 0; i < a.length-1; i++){
    for( int j = 0; j < a.length-1-i; j++){
        if(a[j] > a[j+1]){
            int temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
        }
    }
}
for( int i = 0; i < a.length; i++){
    System.out.print(a[i]+ " ");
}
```

## 分析过程

- ## 分析冒泡排序
- ## 初始数组

  - ## `[24, 69, 80, 57, 13]`

- ## ==第 1 轮排序==：目标把最大数放在最后

  - ## 第 1 次比较：`[24, 69, 80, 57, 13]`
  - ## 第 2 次比较：`[24, 69, 80, 57, 13]`
  - ## 第 3 次比较：`[24, 69, 57, 80, 13]`
  - ## 第 4 次比较：`[24, 69, 57, 13, 80]`

- ## ==第 2 轮排序==：目标把第二大数放在倒数第二位置

  - ## 第 1 次比较：`[24, 69, 57, 13, 80]`
  - ## 第 2 次比较：`[24, 57, 69, 13, 80]`
  - ## 第 3 次比较：`[24, 57, 13, 69, 80]`

- ## ==第 3 轮排序==：目标把第 3 大数放在倒数第 3 位置

  - ## 第 1 次比较：`[24, 57, 13, 69, 80]`
  - ## 第 2 次比较：`[24, 13, 57, 69, 80]`

- ## ==第 4 轮排序==：目标把第 4 大数放在倒数第 4 位置
  - ## 第 1 次比较：`[13, 24, 57, 69, 80]`

## 思路：

## 1. 外层`for`循环：表示需要进行排序的轮次，即每一次都找出最大的数排在队尾，需要排序`数组长度-1`次才可以排完

## 2. 内层`for`循环：表示每一轮排序把最大的放在数组末尾的这个过程的实现元素之间需要比较的轮次，每排序好一个元素，比较的轮次就减少，和外层循环有关

## ==大体思想：化繁为简，先死后活，由内层推出的外层==

## [视频教学连接：透彻理解 Java 冒泡排序的实现方法](https://www.bilibili.com/video/BV1fh411y7R8?spm_id_from=333.788.videopod.episodes&vd_source=822e86b53dab98632ef279a46d2536db&p=174)
