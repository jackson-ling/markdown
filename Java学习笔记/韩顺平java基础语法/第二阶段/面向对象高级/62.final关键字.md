# final 关键字

---

# 一、final 关键字介绍

- ## 1. ==final==可以修饰==类、属性、方法和局部变量==
- ## 2. ==final 的使用场景==
  - ## （1）==`类`不能被继承==时，可以使用`final`修饰
  - ## （2）==类的某个`属性`不可以被更改==，可以使用`final`修饰
  - ## （3）==父类的某个`方法`不能被子类重写==，可以使用`final`修饰
  - ## （4）==某个`局部变量`不能被修改==，可以使用`final`修饰
    - ## 补充说明：关于局部变量
      - ## 1. 可以是==循环中==的局部变量
      - ## 2. 可以是==方法中==的局部变量

---

# 二、final 关键字==使用细节==

- ## （1）`final` 修饰的属性又叫==常量==，一般用 ==XX_XX_XX== 来命名。
- ## （2）`final` 修饰的属性在==定义时，必须赋初值==，并且以后不能再修改，赋值可以在如下位置之一（选择一个位置赋初值即可）
  - ## 1. 在==定义==时
  - ## 2. 在==构造器==中
  - ## 3. 在==代码块==中
- ## （3）如果 `final` 修饰的==属性==是==静态的==，则初始化的位置只能是
  - ## 1. 在==定义==时
  - ## 2. 在==静态代码块==中
  - ## 3. ==不能在构造器中赋值==
- ## （4）`final` 类==不能继承==，但是==可以实例化对象==（可以创建一个 final 类的对象）
- ## （5）如果类不是 `final` 类，但是含有 `final` 方法，则该==方法不能重写，但是可以被继承==
- ## （6）代码规范：如果一个类已经是`final`类了，就没有必要再将该类中的方法修饰成`final`方法了
- ## （7）==`final`不能修饰构造器==
- ## （8）包装类（`Integer`，`Double`，`Float`，`Boolean`等都是`final`），`String`也是`final`类
- ## （9）（==重点！==）`final`和`static`往往搭配使用，效率更高，==不会导致类加载==（底层编译器做了优化处理）
  - ## 理解：为什么不会导致类加载？
    - ## 1. 编译器将 static final 的常量值直接==存储到==调用类的==常量池==中。
    - ## 2. 使用该常量时，==JVM 直接使用常量池中的值==，==不需要访问定义常量的类==，自然就不会触发类的初始化（即类加载）。

## 代码示例：解释第 9 点

```java
package final_;

public class main {
    public static void main(String[] args) {
        System.out.println(A.a);
    }
}

class A{
    public final static int a = 10;

    static {
        System.out.println("代码块被调用");
    }

    public A(){
        System.out.println("构造器被调用");
    }
}

// 输出结果
10
```

## 代码解析

## `final`和`static`搭配使用修饰一个属性，调用该属性时==不会导致类的加载==，即==不会执行代码块中的内容==
