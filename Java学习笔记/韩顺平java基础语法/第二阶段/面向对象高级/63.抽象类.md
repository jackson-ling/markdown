# 抽象类

---

## 引入关键字：==abstract==

## 应用场景：当子类中==共有的部分 / 特性==可以放到抽象类中

- ## 1. 通过==子类的方法重写==实现不同的功能
- ## 2. 编写一个方法把共有的部分放入其中，在该方法中调用抽象方法（==动态绑定机制==）
- ## 3. 便可以实现不同类中共有的功能的同时还能实现自身的方法
- ## 4. ==提高了代码的复用性==

## 抽象类介绍

- ## 1. 使用`abstract`关键字修饰一个类时，这个类就叫抽象类
- ## 2. ==抽象方法没有方法体==
  - ## 例：`public abstract void hi();`
- ## 3. 面试中爱问，在框架和设计模式使用较多

---

# 一、快速入门

## 案例：两个子类的方法都需要提示程序的开始和结束，编写不同的数学方法

## 代码示例

```java
package abstract_;

public class main {
    public static void main(String[] args) {
        a a = new a();
        a.show();
        System.out.println("------------------------------------");
        b b = new b();
        b.show();
    }
}

abstract class shared {

    public abstract void tool(int a, int b); // 抽象方法不可以有方法体

    public void show() {
        System.out.println("你进入了抽象类的show方法：开始执行");
        tool(2,3);
        System.out.println("你退出了抽象类的show方法：执行结束");
    }
}


class a extends shared {

    public void tool(int a, int b) {
        System.out.println("a + b = " + (a + b));
    }
}

class b extends shared {
    public void tool(int a, int b) {
        System.out.println("a * b = " + (a * b));
    }
}

//输出结果
你进入了抽象类的show方法：开始执行
a + b = 5
你退出了抽象类的show方法：执行结束
------------------------------------
你进入了抽象类的show方法：开始执行
a * b = 6
你退出了抽象类的show方法：执行结束
```

## 代码解析

- ## 1. 两个数学方法都需要再方法执行的开头和结尾提示信息，==共有的部分==放入抽象类中的方法中
- ## 2. 子类通过重写抽象类的`tool()`方法实现不同的功能
- ## 3. 为了实现共有的部分，再方法中调用子类的方法实现不同的功能
- ## 4. 代码执行的==核心==：==动态绑定机制和继承关系==

## >>本案例中的==动态绑定机制==实现说明（以 ==对象 a== 为例）

- ## 1. 首先明确继承关系，创建==a 对象==时，区别编译类型和运行类型
- ## 2. show（）方法在在类中子类没有，寻找父类，调用父类中的 show（）方法
- ## 3. 进入 show（）方法，由于==运行类型是 a 对象，则调用 a 对象的 job 方法==

---

# 二、使用细节

- ## （1）==抽象类不能实例化==（不可以创建一个抽象类对象）
- ## （2）抽象类不一定要包含 abstract 方法。也就是说，抽象类可以没有 abstract 方法
- ## （3）一旦==类包含了 abstract 方法==，则这个类==必须声明为 abstract==
- ## （4）`abstract`==只能修饰类和方法==，不能修饰属性和其它的。
- ## （5）==抽象方法不能有方法体==
- ## （6）==抽象类可以有任意成员==（抽象类本质还是类），比如：非抽象方法、构造器、静态属性等等
- ## （7）抽象方法==不能使用==`private`、`final` 和 `static`来修饰，==这些关键字都是和`重写`相违背的==
  - ## 1. `private`：私有的，访问权限上不允许，无法重写
  - ## 2. `final`：不可以被修改，无法重写
  - ## 3. `static`：和重写无关的关键字

---

# 三、==模板设计模式==（抽象类的实际应用）

- ## （1）基本介绍：抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
- ## （2）模板设计模式==解决的问题==
  - ## 1. 当功能内部一部分实现是确定的，一部分实现是不确定的时候，可以把不确定的部分暴露出去，让子类去实现。
  - ## 2. 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式
